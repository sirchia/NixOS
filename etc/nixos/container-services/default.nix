# configuration.nix

{ config, pkgs, lib, inputs, ... }:

{
  imports =
    [
      ./networks.nix
      ./infra.nix
      ./traefik.nix
      ./hass.nix
      ./media.nix
      ./apps.nix
    ];

  # System Packages
  environment.systemPackages = with pkgs; [
    podman-compose
    docker-compose
  ];

  boot.kernel.sysctl = {
    "net.ipv4.ip_unprivileged_port_start" = 53;
  };

  # Runtime 
  virtualisation.podman = { 
    enable = true; 
    autoPrune.enable = true; 
    dockerCompat = true; 
    dockerSocket.enable = true;
  }; 

  virtualisation.oci-containers.backend = "podman"; 

  systemd = {
    services.podman-prune.unitConfig.OnFailure = "notify-service-failure@%i.service";
    services.podman-prune.unitConfig.OnSuccess = "notify-service-success@%i.service";

    services."podman-auto-update" = {
      enable = true;
      description = "Automatic update of all podman containers";
      path = [ pkgs.podman ];
      unitConfig = {
        OnFailure = "notify-service-failure@%i.service";
        OnSuccess = "notify-service-success@%i.service";
      };
      serviceConfig = {
        Type = "oneshot";
        ExecStart = "/persist/scripts/pcmanage.sh update";
      };
    };

    timers."podman-auto-update" = {
      description = "Daily automatic update of all podman containers";
      wantedBy = [ "timers.target" ];
      timerConfig = {
        OnCalendar = "02:12";
        Persistent = true;
        Unit = "podman-auto-update.service";
      };
    };

  };

  # Root service
  # When started, this will automatically create all resources and start
  # the containers. When stopped, this will teardown all resources.
  systemd.targets."podman-compose-root" = {
    unitConfig = {
      Description = "Root target generated by compose2nix.";
    };
    wantedBy = [ "multi-user.target" ];
  };
}
